
<html><head></head><head></head><head></head><head></head><body><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; background-color: transparent; "><h1 id="internal-source-marker_0.9001555698923767"><span style="font-size: 24pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Faucet Networking Extension</span></h1><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The extension uses integer handles to allow Game Maker programs to refer to sockets, buffers and other objects. Passing an invalid handle to a function will generate reasonable behaviour. For example, socket functions will pretend that the handle belongs to a socket in error state, and reading the error string will return an appropriate message.</span><br><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br><span style="font-size: 12pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Connecting and disconnecting</span><br><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">tcp_connect(server, port) : tcpSocket</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">server</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> is a string containing an IPv4 or IPv6 address or a hostname.</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">port</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> is an integer in the range of 1 to 65535</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The returned socket can instantly be used in sending and receiving operations and will buffer sent data internally until the connection attempt is actually done.</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">A failed connection attempt can be identified by querying socket_has_error() once socket_connecting() returns false.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_connecting(socket) : bool</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Returns true if the socket is currently performing a connection attempt.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_has_error(socket | acceptor) : bool</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">When this function returns true the socket or acceptor is no longer able to perform its function. </span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">For a TCP socket, this means that it can no longer send or receive data over the network. Trying to send additional data is useless (but harmless), and trying to read anything will fail as if there was simply no data available.</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">For an acceptor it means that no new connections will be accepted. </span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The function socket_error() can be used to get a description of the error.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">tcp_listen(port) : acceptor</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Create a new acceptor to listen for incoming connections on the indicated port (1-65535). Both IPv4 and IPv6 connections to that port will be accepted. If an error occurs, the returned acceptor will indicate the failure. Please note that acceptors will only flag an error if both IPv4 and IPv6 connections can't be accepted anymore.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_accept(acceptor) : socket | errorcode</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Accept a connection from an acceptor. If a connection is available, a (non-negative) socket handle is returned, which is of the same protocol type as the listening socket. If no connection is available, a negative value is returned.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_destroy(socket | acceptor, abortive) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Closes the connection and destroys the socket. All sockets and acceptors have to be destroyed in this way, even if they are already closed or in an error state, to release the associated resources.</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">If </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">abortive </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">is true, the connection will be closed immediately without trying to send any remaining data (abortive close using RST). Otherwise it will attempt to send all data from the sendbuffer before closing (graceful close with FIN). In general, use a graceful close if you are closing the connection because there is nothing left to send or receive, and use an abortive close if you want to cut off a connection because of an error. The remote socket will indicate an abortive close as an error.</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">In either case the socket handle will become invalid immediately and shouldn’t be used again afterwards.</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">abortive </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">has no effect for acceptors.</span></p><h4><span style="font-size: 12pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Sending and receiving information</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span></h4><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_[xxx](socket, real) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Append data to the end of the socket’s sendbuffer. These functions are shortcuts that behave like the corresponding functions for buffers, but they operate directly on the socket’s sendbuffer.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_string(socket, string) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Append a string in Game Maker’s 8 bit character encoding to the socket’s sendbuffer. This will only write the raw characters, no length information or delimiter is included, so you will want to do that yourself.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_buffer(socket, buffer) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Append the given buffer to the end of this socket’s sendbuffer.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">tcp_receive(tcpSocket, size) : buffer | errorcode</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Try reading </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">size</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> bytes and return them as a new buffer. If the requested number of bytes is not available, a receive operation is started in the background to read at least as many bytes as requested, so that calling this function again later can succeed.</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Returns either the handle of a new buffer, or a negative value to indicate that not enough bytes were available. Remember to destroy the buffer after use.</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">If the connection was closed by the remote end and more bytes are requested than are remaining to be read, the requested number of bytes can never become available. In this case the socket will transition to an error state.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">tcp_receive_available(tcpSocket) : buffer</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Read all data currently available from the socket and return it in a new buffer. The buffer will be empty if no data is available at the moment. Remember to destroy the buffer after use.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">tcp_eof(socket) : bool</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Determine if there is no more data to read. This means that the connection is closed in the receiving direction, either because the sender has closed it or because of an error, and all internally buffered data has been read. In that case, attempting to read any more data from this socket will cause the socket to report an error.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_send(socket) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Try to send data from the internal sendbuffer out through the socket. If you call this function too often, it might result in many small TCP packets being sent, which causes a lot of overhead and thus needs more bandwidth. If you call it too seldom, the data will sit in the sendbuffer for a longer time before being sent, so you get larger delays. A good time to call this is right after you’re done writing things to the sendbuffer of this socket for this step.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_sendbuffer_size(socket) : size</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">How many bytes are in the sendbuffer?</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">If the connection can’t send data as fast as the application demands, the sendbuffer will grow. This function can be used to detect slow connections and reduce the data rate. However, the result should be taken with a large grain of salt. The number returned does not include data already queued for sending in the network layer, and this can be a lot of data (in the order of megabytes). If you send data in many small chunks though, there should be less of that queued data and you should see a growing backlog in the sendbuffer pretty quickly.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_sendbuffer_limit(socket, size) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Prevent the sendbuffer from growing larger than this value (in bytes). 0 means no limit. If the sendbuffer would exceed this capacity the connection will be closed and an appropriate error will be indicated. There is no default limit since a reasonable value depends heavily on the application. To prevent “out of memory” problems it is recommended to set this limit on every socket.</span></p><h4><span style="font-size: 12pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Buffers</span></h4><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Buffers typically contain data that has been received or should be sent.</span><br><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Handing an invalid buffer handle to a buffer function will cause the function to behave as if it was called on a constantly empty buffer. </span><br><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">buffer_create() : buffer</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Create a new, empty buffer.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">buffer_destroy(buffer) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Destroy a buffer and release its handle. This function should be called on all buffers that are no longer needed to release the memory allocated to them.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">buffer_clear(buffer) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Remove all content from the buffer, so that it behaves exactly like a buffer that has only just been created.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">buffer_size(buffer) : size</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Returns the number of bytes in the buffer.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">buffer_bytes_left(buffer) : size</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Returns the number of bytes that can still be read from the buffer.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">buffer_set_readpos(buffer, pos) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Set the read pointer of the buffer to a new position (given in bytes). The given position will be clipped to the beginning and the end of the buffer if it is below 0 or above buffer_size(buffer). There is no corresponding buffer_get_readpos(), if you really need this you can calculate it as buffer_size(buffer)-buffer_bytes_left(buffer).</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_[xxx](buffer, real) : void</span></h6><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "><span class="Apple-tab-span" style="white-space: pre; ">	</span>Append the given value to the end of the buffer. The following functions are supported:</span><br><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_ubyte<span class="Apple-tab-span" style="white-space: pre; ">	</span><span class="Apple-tab-span" style="white-space: pre; ">	</span>8 bit unsigned integer</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_byte<span class="Apple-tab-span" style="white-space: pre; ">	</span><span class="Apple-tab-span" style="white-space: pre; ">	</span>8 bit signed integer</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_ushort<span class="Apple-tab-span" style="white-space: pre; ">	</span><span class="Apple-tab-span" style="white-space: pre; ">	</span>16 bit unsigned integer</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_short<span class="Apple-tab-span" style="white-space: pre; ">	</span><span class="Apple-tab-span" style="white-space: pre; ">	</span>16 bit signed integer</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_uint<span class="Apple-tab-span" style="white-space: pre; ">	</span><span class="Apple-tab-span" style="white-space: pre; ">	</span></span><span class="Apple-style-span" style="font-family: Arial; font-size: 15px; white-space: pre-wrap; "><span class="Apple-tab-span" style="white-space: pre; ">	</span></span><span class="Apple-style-span" style="font-family: Arial; font-size: 15px; white-space: pre-wrap; ">32 bit unsigned integer</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_int<span class="Apple-tab-span" style="white-space: pre; ">	</span><span class="Apple-tab-span" style="white-space: pre; ">	</span></span><span class="Apple-style-span" style="font-family: Arial; font-size: 15px; white-space: pre-wrap; "><span class="Apple-tab-span" style="white-space: pre; ">	</span></span><span class="Apple-style-span" style="font-family: Arial; font-size: 15px; white-space: pre-wrap; ">32 bit signed integer</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_float<span class="Apple-tab-span" style="white-space: pre; ">	</span><span class="Apple-tab-span" style="white-space: pre; ">	</span>32 bit floating point value</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_double<span class="Apple-tab-span" style="white-space: pre; ">	</span><span class="Apple-tab-span" style="white-space: pre; ">	</span>64 bit floating point value</span></p><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Normal C type conversion is applied to cast the given real value to the selected type. Most importantly, fractional parts will be cut off when converting to integer (so 42.9 would be sent as 42).</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_string(buffer, string) : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Append a string in Game Maker’s 8 bit character encoding to the buffer. This will only write the raw characters, no length information or delimiter is included, so you will want to do that yourself.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">write_buffer(buffer, otherBuffer) : void</span></h6><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "><span class="Apple-tab-span" style="white-space: pre; ">	</span>Append the contents of </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">otherBuffer</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> to this buffer.</span><br><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">read_[xxx](buffer) : real</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Read a value of the expected type from the buffer, starting at its current read position. The read position will be advanced to the next byte after the read value. If there are not enough bytes left in the buffer, the returned value is undefined and the read position is set to the end of the buffer. If the buffer does not exist, 0 is returned. See write_[xxx] for possible types.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">read_string(buffer, size) : string</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Read the given number of characters from the buffer and return them as a string. The reading starts at the buffer’s current read position. The read position will be advanced to the next byte after the read characters. If there are not enough bytes left in the buffer, the returned string will be shorter than requested and the read position is set to the end of the buffer.</span></p><h4><span style="font-size: 12pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Miscellaneous</span></h4><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_error(socket | acceptor) : string</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Returns a string description of the current error status. This function can return a message even if socket_has_error() returns false. This is particularly the case for acceptors, which can fail partially (for one protocol) but won’t flag an error while there’s still a usable protocol. For acceptors the error messages for all protocols are returned.</span></p><h6><span style="font-size: 10pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">socket_handle_io() : void</span></h6><p style="margin-left: 36pt; margin-top: 0pt; margin-bottom: 0pt; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">This function should be called once every step to allow the networking library to perform background tasks. There is usually no sense in calling this function more than once per step, because most networking functions will call it internally anyway. So if you are busy-waiting for e.g. a connection to be established, it will work as expected without having to call this function in your loop.</span></p></div></body></html>